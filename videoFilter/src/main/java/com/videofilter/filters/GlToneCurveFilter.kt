/*
 * Copyright (C) 2007 Free Software Foundation, Inc.
 *  Everyone is permitted to copy and distribute verbatim copies
 *  of this license document, but changing it is not allowed.
 *
 *
 *   This version of the GNU Lesser General Public License incorporates
 * the terms and conditions of version 3 of the GNU General Public
 * License, supplemented by the additional permissions listed below.
 *
 *   0. Additional Definitions.
 *
 *   As used herein, "this License" refers to version 3 of the GNU Lesser
 * General Public License, and the "GNU GPL" refers to version 3 of the GNU
 * General Public License.
 *
 *   "The Library" refers to a covered work governed by this License,
 * other than an Application or a Combined Work as defined below.
 *
 *   An "Application" is any work that makes use of an interface provided
 * by the Library, but which is not otherwise based on the Library.
 * Defining a subclass of a class defined by the Library is deemed a mode
 * of using an interface provided by the Library.
 *
 *   A "Combined Work" is a work produced by combining or linking an
 * Application with the Library.  The particular version of the Library
 * with which the Combined Work was made is also called the "Linked
 * Version".
 *
 *   The "Minimal Corresponding Source" for a Combined Work means the
 * Corresponding Source for the Combined Work, excluding any source code
 * for portions of the Combined Work that, considered in isolation, are
 * based on the Application, and not on the Linked Version.
 *
 *   The "Corresponding Application Code" for a Combined Work means the
 * object code and/or source code for the Application, including any data
 * and utility programs needed for reproducing the Combined Work from the
 * Application, but excluding the System Libraries of the Combined Work.
 *
 *   1. Exception to Section 3 of the GNU GPL.
 *
 *   You may convey a covered work under sections 3 and 4 of this License
 * without being bound by section 3 of the GNU GPL.
 *
 *   2. Conveying Modified Versions.
 *
 *   If you modify a copy of the Library, and, in your modifications, a
 * facility refers to a function or data to be supplied by an Application
 * that uses the facility (other than as an argument passed when the
 * facility is invoked), then you may convey a copy of the modified
 * version:
 *
 *    a) under this License, provided that you make a good faith effort to
 *    ensure that, in the event an Application does not supply the
 *    function or data, the facility still operates, and performs
 *    whatever part of its purpose remains meaningful, or
 *
 *    b) under the GNU GPL, with none of the additional permissions of
 *    this License applicable to that copy.
 *
 *   3. Object Code Incorporating Material from Library Header Files.
 *
 *   The object code form of an Application may incorporate material from
 * a header file that is part of the Library.  You may convey such object
 * code under terms of your choice, provided that, if the incorporated
 * material is not limited to numerical parameters, data structure
 * layouts and accessors, or small macros, inline functions and templates
 * (ten or fewer lines in length), you do both of the following:
 *
 *    a) Give prominent notice with each copy of the object code that the
 *    Library is used in it and that the Library and its use are
 *    covered by this License.
 *
 *    b) Accompany the object code with a copy of the GNU GPL and this license
 *    document.
 *
 *   4. Combined Works.
 *
 *   You may convey a Combined Work under terms of your choice that,
 * taken together, effectively do not restrict modification of the
 * portions of the Library contained in the Combined Work and reverse
 * engineering for debugging such modifications, if you also do each of
 * the following:
 *
 *    a) Give prominent notice with each copy of the Combined Work that
 *    the Library is used in it and that the Library and its use are
 *    covered by this License.
 *
 *    b) Accompany the Combined Work with a copy of the GNU GPL and this license
 *    document.
 *
 *    c) For a Combined Work that displays copyright notices during
 *    execution, include the copyright notice for the Library among
 *    these notices, as well as a reference directing the user to the
 *    copies of the GNU GPL and this license document.
 *
 *    d) Do one of the following:
 *
 *        0) Convey the Minimal Corresponding Source under the terms of this
 *        License, and the Corresponding Application Code in a form
 *        suitable for, and under terms that permit, the user to
 *        recombine or relink the Application with a modified version of
 *        the Linked Version to produce a modified Combined Work, in the
 *        manner specified by section 6 of the GNU GPL for conveying
 *        Corresponding Source.
 *
 *        1) Use a suitable shared library mechanism for linking with the
 *        Library.  A suitable mechanism is one that (a) uses at run time
 *        a copy of the Library already present on the user's computer
 *        system, and (b) will operate properly with a modified version
 *        of the Library that is interface-compatible with the Linked
 *        Version.
 *
 *    e) Provide Installation Information, but only if you would otherwise
 *    be required to provide such information under section 6 of the
 *    GNU GPL, and only to the extent that such information is
 *    necessary to install and execute a modified version of the
 *    Combined Work produced by recombining or relinking the
 *    Application with a modified version of the Linked Version. (If
 *    you use option 4d0, the Installation Information must accompany
 *    the Minimal Corresponding Source and Corresponding Application
 *    Code. If you use option 4d1, you must provide the Installation
 *    Information in the manner specified by section 6 of the GNU GPL
 *    for conveying Corresponding Source.)
 *
 *   5. Combined Libraries.
 *
 *   You may place library facilities that are a work based on the
 * Library side by side in a single library together with other library
 * facilities that are not Applications and are not covered by this
 * License, and convey such a combined library under terms of your
 * choice, if you do both of the following:
 *
 *    a) Accompany the combined library with a copy of the same work based
 *    on the Library, uncombined with any other library facilities,
 *    conveyed under the terms of this License.
 *
 *    b) Give prominent notice with the combined library that part of it
 *    is a work based on the Library, and explaining where to find the
 *    accompanying uncombined form of the same work.
 *
 *   6. Revised Versions of the GNU Lesser General Public License.
 *
 *   The Free Software Foundation may publish revised and/or new versions
 * of the GNU Lesser General Public License from time to time. Such new
 * versions will be similar in spirit to the present version, but may
 * differ in detail to address new problems or concerns.
 *
 *   Each version is given a distinguishing version number. If the
 * Library as you received it specifies that a certain numbered version
 * of the GNU Lesser General Public License "or any later version"
 * applies to it, you have the option of following the terms and
 * conditions either of that published version or of any later version
 * published by the Free Software Foundation. If the Library as you
 * received it does not specify a version number of the GNU Lesser
 * General Public License, you may choose any version of the GNU Lesser
 * General Public License ever published by the Free Software Foundation.
 *
 *   If the Library as you received it specifies that a proxy can decide
 * whether future versions of the GNU Lesser General Public License shall
 * apply, that proxy's public statement of acceptance of any version is
 * permanent authorization for you to choose that version for the
 * Library.
 */
package com.videofilter.filters

import android.graphics.Point
import android.graphics.PointF
import android.opengl.GLES20
import com.videofilter.OpenGlUtils
import java.io.IOException
import java.io.InputStream
import java.nio.ByteBuffer
import java.util.*

class GlToneCurveFilter :
    GlFilter(OpenGlUtils.DEFAULT_VERTEX_SHADER, FRAGMENT_SHADER) {
    private var rgbCompositeControlPoints: Array<PointF?>
    private var redControlPoints: Array<PointF?>
    private var greenControlPoints: Array<PointF?>
    private var blueControlPoints: Array<PointF?>
    private var rgbCompositeCurve: ArrayList<Float>? = null
    private var redCurve: ArrayList<Float>? = null
    private var greenCurve: ArrayList<Float>? = null
    private var blueCurve: ArrayList<Float>? = null
    private val runOnDraw: LinkedList<Runnable>
    private val textures = IntArray(1)
    private lateinit var toneCurveByteArray: ByteArray
    override fun setUpSurface() {
        super.setUpSurface()
        GLES20.glGenTextures(1, textures, 0)
        GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, textures[0])
        GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MIN_FILTER, GLES20.GL_LINEAR)
        GLES20.glTexParameteri(GLES20.GL_TEXTURE_2D, GLES20.GL_TEXTURE_MAG_FILTER, GLES20.GL_LINEAR)
        GLES20.glTexParameteri(
            GLES20.GL_TEXTURE_2D,
            GLES20.GL_TEXTURE_WRAP_S,
            GLES20.GL_CLAMP_TO_EDGE
        )
        GLES20.glTexParameteri(
            GLES20.GL_TEXTURE_2D,
            GLES20.GL_TEXTURE_WRAP_T,
            GLES20.GL_CLAMP_TO_EDGE
        )
        while (!runOnDraw.isEmpty()) {
            runOnDraw.removeFirst().run()
        }
    }

    override fun onDraw() {
        val offsetDepthMapTextureUniform = getHandle("toneCurveTexture") // 3
        GLES20.glActiveTexture(GLES20.GL_TEXTURE3)
        GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, textures[0])
        GLES20.glTexImage2D(
            GLES20.GL_TEXTURE_2D,
            0,
            GLES20.GL_RGBA,
            256 /*width*/,
            1 /*height*/,
            0,
            GLES20.GL_RGBA,
            GLES20.GL_UNSIGNED_BYTE,
            ByteBuffer
                .wrap(toneCurveByteArray)
        )
        GLES20.glUniform1i(offsetDepthMapTextureUniform, 3)
    }

    private fun setFromCurveFileInputStream(input: InputStream) {
        try {
            val version = readShort(input).toInt()
            val totalCurves = readShort(input).toInt()
            val curves =
                ArrayList<Array<PointF?>>(totalCurves)
            val pointRate = 1.0f / 255
            for (i in 0 until totalCurves) {
                // 2 bytes, Count of points in the curve (short integer toAndroidFormat 2...19)
                val pointCount = readShort(input)
                val points = arrayOfNulls<PointF>(pointCount.toInt())

                // point count * 4
                // Curve points. Each curve point is a pair of short integers where
                // the first number is the output getNode (vertical coordinate on the
                // Curves dialog graph) and the second is the input getNode. All coordinates have range 0 to 255.
                for (j in 0 until pointCount) {
                    val y = readShort(input)
                    val x = readShort(input)
                    points[j] = PointF(x * pointRate, y * pointRate)
                }
                curves.add(points)
            }
            input.close()
            rgbCompositeControlPoints = curves[0]
            redControlPoints = curves[1]
            greenControlPoints = curves[2]
            blueControlPoints = curves[3]
        } catch (e: IOException) {
            e.printStackTrace()
        }
    }

    @Throws(IOException::class)
    private fun readShort(input: InputStream): Short {
        return (input.read() shl 8 or input.read()).toShort()
    }

    private fun setRgbCompositeControlPoints(points: Array<PointF?>) {
        rgbCompositeControlPoints = points
        rgbCompositeCurve = createSplineCurve(rgbCompositeControlPoints)
        updateToneCurveTexture()
    }

    private fun setRedControlPoints(points: Array<PointF?>) {
        redControlPoints = points
        redCurve = createSplineCurve(redControlPoints)
        updateToneCurveTexture()
    }

    private fun setGreenControlPoints(points: Array<PointF?>) {
        greenControlPoints = points
        greenCurve = createSplineCurve(greenControlPoints)
        updateToneCurveTexture()
    }

    private fun setBlueControlPoints(points: Array<PointF?>) {
        blueControlPoints = points
        blueCurve = createSplineCurve(blueControlPoints)
        updateToneCurveTexture()
    }

    private fun runOnDraw(runnable: Runnable) {
        synchronized(runOnDraw) { runOnDraw.addLast(runnable) }
    }

    private fun updateToneCurveTexture() {
        runOnDraw(Runnable {
            GLES20.glActiveTexture(GLES20.GL_TEXTURE1)
            GLES20.glBindTexture(GLES20.GL_TEXTURE_2D, textures[0])
            if (redCurve!!.size >= 256 && greenCurve!!.size >= 256 && blueCurve!!.size >= 256 && rgbCompositeCurve!!.size >= 256) {
                toneCurveByteArray = ByteArray(256 * 4)
                for (currentCurveIndex in 0..255) {
                    // BGRA for upload to texture
                    toneCurveByteArray[currentCurveIndex * 4 + 2] = (Math.min(
                        Math.max(
                            currentCurveIndex + blueCurve!![currentCurveIndex] + rgbCompositeCurve!![currentCurveIndex],
                            0f
                        ), 255f
                    ).toInt() and 0xff).toByte()
                    toneCurveByteArray[currentCurveIndex * 4 + 1] = (Math.min(
                        Math.max(
                            currentCurveIndex + greenCurve!![currentCurveIndex] + rgbCompositeCurve!![currentCurveIndex],
                            0f
                        ), 255f
                    ).toInt() and 0xff).toByte()
                    toneCurveByteArray[currentCurveIndex * 4] = (Math.min(
                        Math.max(
                            currentCurveIndex + redCurve!![currentCurveIndex] + rgbCompositeCurve!![currentCurveIndex],
                            0f
                        ), 255f
                    ).toInt() and 0xff).toByte()
                    toneCurveByteArray[currentCurveIndex * 4 + 3] =
                        (255 and 0xff).toByte()
                }
                GLES20.glTexImage2D(
                    GLES20.GL_TEXTURE_2D,
                    0,
                    GLES20.GL_RGBA,
                    256 /*width*/,
                    1 /*height*/,
                    0,
                    GLES20.GL_RGBA,
                    GLES20.GL_UNSIGNED_BYTE,
                    ByteBuffer
                        .wrap(toneCurveByteArray)
                )
            }
            //        Buffer pixels!
//        GLES20.glTexImage2D(int target,
//            int level,
//            int internalformat,
//            int width,
//            int height,
//            int border,
//            int format,
//            int type,
//            java.nio.Buffer pixels);
        })
    }

    private fun createSplineCurve(points: Array<PointF?>?): ArrayList<Float>? {
        if (points == null || points.size <= 0) {
            return null
        }

        // Sort the array
        val pointsSorted: Array<PointF?> = points.clone()
        Arrays.sort(pointsSorted) { point1, point2 ->
            when {
                point1!!.x < point2!!.x -> {
                    -1
                }
                point1.x > point2.x -> {
                    1
                }
                else -> {
                    0
                }
            }
        }

        // Convert toAndroidFormat (0, 1) to (0, 255).
        val convertedPoints =
            arrayOfNulls<Point>(pointsSorted.size)
        for (i in points.indices) {
            val point = pointsSorted[i]
            convertedPoints[i] =
                Point((point!!.x * 255).toInt(), (point.y * 255).toInt())
        }
        val splinePoints =
            createSplineCurve2(convertedPoints)

        // If we have a first point like (0.3, 0) we'll be missing some points at the beginning
        // that should be 0.
        val firstSplinePoint = splinePoints!![0]
        if (firstSplinePoint!!.x > 0) {
            for (i in firstSplinePoint.x downTo 0) {
                splinePoints.add(0, Point(i, 0))
            }
        }

        // Insert points similarly at the end, if necessary.
        val lastSplinePoint = splinePoints[splinePoints.size - 1]
        if (lastSplinePoint!!.x < 255) {
            for (i in lastSplinePoint.x + 1..255) {
                splinePoints.add(Point(i, 255))
            }
        }

        // Prepare the spline points.
        val preparedSplinePoints =
            ArrayList<Float>(splinePoints.size)
        for (newPoint in splinePoints) {
            val origPoint = Point(newPoint!!.x, newPoint.x)
            var distance = Math.sqrt(
                Math.pow((origPoint.x - newPoint.x).toDouble(), 2.0) + Math.pow(
                    (origPoint.y - newPoint.y).toDouble(),
                    2.0
                )
            ).toFloat()
            if (origPoint.y > newPoint.y) {
                distance = -distance
            }
            preparedSplinePoints.add(distance)
        }
        return preparedSplinePoints
    }

    private fun createSplineCurve2(points: Array<Point?>): ArrayList<Point?>? {
        val sdA = createSecondDerivative(points)

        // Is [points count] equal to [sdA count]?
//    int n = [points count];
        val n = sdA!!.size
        if (n < 1) {
            return null
        }
        val sd = DoubleArray(n)

        // From NSMutableArray to sd[n];
        for (i in 0 until n) {
            sd[i] = sdA[i]
        }
        val output =
            ArrayList<Point?>(n + 1)
        for (i in 0 until n - 1) {
            val cur = points[i]
            val next = points[i + 1]
            for (x in cur!!.x until next!!.x) {
                val t = (x - cur.x).toDouble() / (next.x - cur.x)
                val a = 1 - t
                val h = next.x - cur.x.toDouble()
                var y =
                    a * cur.y + t * next.y + h * h / 6 * ((a * a * a - a) * sd[i] + (t * t * t - t) * sd[i + 1])
                if (y > 255.0) {
                    y = 255.0
                } else if (y < 0.0) {
                    y = 0.0
                }
                output.add(Point(x, Math.round(y).toInt()))
            }
        }

        // If the last point is (255, 255) it doesn't get added.
        if (output.size == 255) {
            output.add(points[points.size - 1])
        }
        return output
    }

    private fun createSecondDerivative(points: Array<Point?>): ArrayList<Double>? {
        val n = points.size
        if (n <= 1) {
            return null
        }
        val matrix =
            Array(n) { DoubleArray(3) }
        val result = DoubleArray(n)
        matrix[0][1] = 1.0
        // What about matrix[0][1] and matrix[0][0]? Assuming 0 for now (Brad L.)
        matrix[0][0] = 0.0
        matrix[0][2] = 0.0
        for (i in 1 until n - 1) {
            val P1 = points[i - 1]
            val P2 = points[i]
            val P3 = points[i + 1]
            matrix[i][0] = (P2!!.x - P1!!.x).toDouble() / 6
            matrix[i][1] = (P3!!.x - P1.x).toDouble() / 3
            matrix[i][2] = (P3.x - P2.x).toDouble() / 6
            result[i] =
                (P3.y - P2.y).toDouble() / (P3.x - P2.x) - (P2.y - P1.y).toDouble() / (P2.x - P1.x)
        }

        // What about result[0] and result[n-1]? Assuming 0 for now (Brad L.)
        result[0] = 0.0
        result[n - 1] = 0.0
        matrix[n - 1][1] = 1.0
        // What about matrix[n-1][0] and matrix[n-1][2]? For now, assuming they are 0 (Brad L.)
        matrix[n - 1][0] = 0.0
        matrix[n - 1][2] = 0.0

        // solving pass1 (up->down)
        for (i in 1 until n) {
            val k = matrix[i][0] / matrix[i - 1][1]
            matrix[i][1] -= k * matrix[i - 1][2]
            matrix[i][0] = 0.0
            result[i] -= k * result[i - 1]
        }
        // solving pass2 (down->up)
        for (i in n - 2 downTo 0) {
            val k = matrix[i][2] / matrix[i + 1][1]
            matrix[i][1] -= k * matrix[i + 1][0]
            matrix[i][2] = 0.0
            result[i] -= k * result[i + 1]
        }
        val output = ArrayList<Double>(n)
        for (i in 0 until n) output.add(result[i] / matrix[i][1])
        return output
    }

    companion object {
        private const val FRAGMENT_SHADER =
            "#extension GL_OES_EGL_image_external : require\n" +
                    " precision mediump float;\n" +
                    " varying vec2 vTextureCoord;\n" +
                    " uniform samplerExternalOES sTexture;\n" +
                    " uniform mediump sampler2D toneCurveTexture;\n" +
                    "\n" +
                    " void main()\n" +
                    " {\n" +
                    "     lowp vec4 textureColor = texture2D(sTexture, vTextureCoord);\n" +
                    "     lowp float redCurveValue = texture2D(toneCurveTexture, vec2(textureColor.r, 0.0)).r;\n" +
                    "     lowp float greenCurveValue = texture2D(toneCurveTexture, vec2(textureColor.g, 0.0)).g;\n" +
                    "     lowp float blueCurveValue = texture2D(toneCurveTexture, vec2(textureColor.b, 0.0)).b;\n" +
                    "\n" +
                    "     gl_FragColor = vec4(redCurveValue, greenCurveValue, blueCurveValue, textureColor.a);\n" +
                    " }"
    }

    init {
        val defaultCurvePoints =
            arrayOf<PointF?>(PointF(0.0f, 0.0f), PointF(0.5f, 0.5f), PointF(1.0f, 1.0f))
        rgbCompositeControlPoints = defaultCurvePoints
        redControlPoints = defaultCurvePoints
        greenControlPoints = defaultCurvePoints
        blueControlPoints = defaultCurvePoints
        runOnDraw = LinkedList()

//        setFromCurveFileInputStream(input);
        setRgbCompositeControlPoints(rgbCompositeControlPoints)
        setRedControlPoints(redControlPoints)
        setGreenControlPoints(greenControlPoints)
        setBlueControlPoints(blueControlPoints)
    }
}